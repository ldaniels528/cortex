*************************************
**		Syntax Ideas
*************************************

1. The language will feature built-in support for lists (ordered), sets (unique) and maps (key-value pairs).
2. The language will also support a built-in Lisp-like map function. 
3. All values are objects including primitive values like integers.
4. Function calls without parameters do not need parenthesis "()"; however,
	function definitions require them.
5. Functions can be used as read-only variables
6. The language will be strongly typed like Java, but will feature
 	conventions found in languages like PHP, Perl, Python, and Ruby.
7. The language will feature a C/C++ line define statement (preprocessor)
8. Specifying the variable type is optional for all built-in types.
 	
-----------------------------------
--	Types - Numeric
-----------------------------------	

sint8			- 8-bit signed integer
byte/uint8		- 8-bit unsigned integer
sint16		 	- 16-bit signed integer
uint16		 	- 16-bit unsigned integer
sint32		 	- 32-bit signed integer
uint32		 	- 32-bit unsigned integer
sint64		 	- 64-bit signed integer
uint64		 	- 64-bit unsigned integer

float32		 	- 32-bit decimal/floating point	
float64		 	- 64-bit decimal/floating point	

-----------------------------------
--	Types - Others
-----------------------------------	

char			- 16-bit Unicode character
dynamic			- pointer to a typed value
string 			- string of characters
list 			- list of objects
set				- unique set of objects (also enum)
hash			- hash table
object			- base type for all types

-----------------------------------
--	Field/Method Modifiers
-----------------------------------	

final
?package
private
protected
public
static

-----------------------------------
--	Method Modifiers
-----------------------------------	

abstract

-----------------------------------
--	Aliases
-----------------------------------	

alias sint32 int;


-----------------------------------
--	Assembly Language
-----------------------------------	

Example 1:
	public class test {
	
		public static void main() {
			// let's put random values in "a" and "b"
			a = random(200);
			b = random(200);
			
			// get the absolute value of the difference
			c = getAbsDifference( a, b );
			printf( "difference = %d\n", c );
		}
		
		static int getAbsDifference( int number1, int number2 ) {
			return ( number1 < number2 ) ? number2 - number1 : number1 - number2;
		}
		
		static int getAbsDifferenceAssy( int number1, int number2 ) {
			int diff = 0;
			
			/* now let's use assembly to determine the 
			   difference "a" and 100 */
			%%
				// setup the values
				mov cx,number1	
				mov ax,number2
				
				// perform the comparison			
				cmp cx,ax
				jge @bigger
				
				// if a < 100
				xchg ax,cx
					
				// if a > 100
				@bigger
					sub cx,ax
				
				// record the difference in b
				mov &diff,rcx
			%%
			// at this point, diff = abs( a - b )
			return diff;
		}
	}

-----------------------------------
--	Lists (@), Sets (#), and Hashes (%)
-----------------------------------

Example 1:
	cbo = {@ {% "hello":1 "bon jour":2, "buenos dias":3 %} {@ 1 2 3 4 @} {# apple banana orange peach #} @}
			// or
	hsh = {% "hello":1 "bon jour":2, "buenos dias":3 %}
	lst = {@ 1 2 3 4 @}
	sts = {# apple banana orange peach #}
	cbo = {@ hsh lst sts @}
	
	? cbo[0] => {% "hello":1 "bon jour":2, "buenos dias":3 %}
	? cbo[1] => {@ 1 2 3 4 @}
	? cbo[2] => {$ apple banana orange peach $}

	a = {@ 1, 2, 3, 4 @};
	print a;
=> ( 1 2 3 4 )	

	list a = {@@};
	a.add(1);
	a.add(2);
	a += ( 3 );
	print a; 
=> ( 1 2 3 )

Example 2:
	list b = {@ 5, 3, 2, 1 @};
	b.sort();
	print b; 
=>	( 1 2 3 4 5 )

	b.pop();
	print b; 
=> ( 1 2 3 4 )

	print a - b; 
=> ( 4 )

Example 3:
	list a = {@ 1 2 3};
	print map(cos, a ); // (cos(1),cos(2),cos(3))
// 	or
	print( a -> cos ); // (cos(1),cos(2),cos(3))
	
Example 4:
	a = {@ 1, 1, 2, 3, 4, 5, 6, 6, 7 @}
	? set(a) => ( 1 2 3 4 5 6 7 )
	
Example 5:

	a = {% "good day":1 "bon jour":2 "buenos dias":3 %}; 
	if( a isa hash ) print "Yes" else print "No"; // Yes
	if( a isa set ) print "Yes" else print "No"; // No
	if( a isa list ) print "Yes" else print "No"; // No
	
	print a.keys;
=> ( "good day" "bon jour" "buenos dias" )

	print a.values;
=> ( "1" "2" "3" )


	
-----------------------------------
--	Objects
-----------------------------------	
	
Example 1:
	print (-1).abs; // 1
	print ++1; // 2
	
	
Example 2:

	class Dog {
		string _name;
		
		name() { return _name; }
	
		name( string _name ) { this._name = _name }
	
		string speak() { ... }
	}

	myDog = Dog.new;
	myDog.name = "Fido"
	puts "My dogs name is ${myDog.name}.\n";
	
=> My dogs name is Fido.
	
-----------------------------------
--	Functions Properties
-----------------------------------	

// If a functions has no parameters, it can
// be accessed like a variable.
	
int value() { ... }
x = value + 5;	// x = value() + 5

// If a function accepts a single parameter, then it
// can be set like a variable

void value( int value ) { ... }
value = 5; 		// value(5)

// If a function has multiple parameters, then it
// can be set using a list.

void info( string name, int age ) { ... }
info = {@ "Lawrence", 35 @};

void printall( list items ) {
	n = 0;
	foreach item : items {
		n++;
		print "${n} ${item}\n";
	}
}

printall( "so long", "far well", "alveitisei", "goodbye" ),

printall = {@ "so long" "far well", "alveitisei", "goodbye" @}

	
-----------------------------------
--	Function Mapping
-----------------------------------	

In Lisp:

(define lst (list 2 3 5 7 11))

(map double lst)
=> (4 6 10 14 22)


In Juxt:

lst = {@ 2,3,5,7,11 @};
int double(int x) { return x + x; }
map(double, lst);
=> (4 6 10 14 22)


-----------------------------------
--	Keyword "switch"
-----------------------------------	

switch name {
	case "Hello":;
		break;

	case "Goodbye":;
		break;
}

switch score {
	case 1:;
		break;
		
	case score > 5:;
		break;

	case score < 5:;
		break;
}


-----------------------------------
--	Math
-----------------------------------

Variables whose types are not explicitly defined
are considered a "dynamic" pointer to a value, therefore
no conversion is performed.

x = 5.1 * y + 7.1;
	or
dynamic x = 5.1 * y + 7.1;


int x = 5.1 * y + 7.1 // => 5*y+7

-----------------------------------
--	Structures
-----------------------------------

struct Customer {
	uint32 customerID;
	string first;
	string last;
	string middle;
	char[9] ssn;
}

-----------------------------------
--	Stores
-----------------------------------

SQLConnection sql = SQL::connect( "oracle", "localhost", "user", "password" );

customerID = 5;
Customer customer <- sql.query( "SELECT customerID, first, last, middle, ssn FROM Customers WHERE customerID = ${customerID}" );
//		or
Customer customer <- ( sql.query <- "SELECT customerID, first, last, middle, ssn FROM Customers WHERE customerID = ${customerID}" );
count = sql.insert <- "INSERT INTO Customers ( first, middle, last ) VALUES ( ${first}, ${middle}, ${last} )";


store<Customer> customeFile = File::store( "C:\temp\dummy.txt" );

-----------------------------------
--	Streams
-----------------------------------
DataOutputStream out = DataOutputStream.new( FileOutputStream.new( "C:\\temp\\dummyOut.txt" ) );
"This is the first line\n" -> out;

// copy the file
string line;
DataInputStream in = DataInputStream.new( FileInputStream.new( "C:\\temp\\dummyIn.txt" ) );
while( line <- in ) { line -> out }
// or
while( ( line <- in ) -> out ) { }

string line;

// get a line from STDIN and write it to STDOUT
line <- System::STDIN;
line -> System:STDOUT;

// get a line from STDIN and write it to STDOUT
( line <- System::STDIN ) -> System:STDOUT;




